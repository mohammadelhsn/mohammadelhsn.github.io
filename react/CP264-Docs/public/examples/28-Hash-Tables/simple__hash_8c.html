<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: simple_hash.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('simple__hash_8c.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">simple_hash.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Code example for CP264 Data Structures II - Array hash table with linear probing for collision handling.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;malloc.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:hashnode" id="r_hashnode"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhashnode.html">hashnode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node structure for use in a hash table with separate chaining.  <a href="structhashnode.html#details">More...</a><br /></td></tr>
<tr class="memitem:hashtable" id="r_hashtable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhashtable.html">hashtable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing a hash table.  <a href="structhashtable.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a70ed59adcb4159ac551058053e649640" id="r_a70ed59adcb4159ac551058053e649640"><td class="memItemLeft" align="right" valign="top"><a id="a70ed59adcb4159ac551058053e649640" name="a70ed59adcb4159ac551058053e649640"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SIZE</b>&#160;&#160;&#160;20</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acba9d1049eee7cf3d1a7ca76f115291f" id="r_acba9d1049eee7cf3d1a7ca76f115291f"><td class="memItemLeft" align="right" valign="top"><a id="acba9d1049eee7cf3d1a7ca76f115291f" name="acba9d1049eee7cf3d1a7ca76f115291f"></a>
typedef struct hashnode&#160;</td><td class="memItemRight" valign="bottom"><b>hashnode</b></td></tr>
<tr class="memitem:a70220a04ca914ec91d54260b4608234a" id="r_a70220a04ca914ec91d54260b4608234a"><td class="memItemLeft" align="right" valign="top"><a id="a70220a04ca914ec91d54260b4608234a" name="a70220a04ca914ec91d54260b4608234a"></a>
typedef struct hashtable&#160;</td><td class="memItemRight" valign="bottom"><b>hashtable</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a50ed8c7958ea9b7b71242a356072101a" id="r_a50ed8c7958ea9b7b71242a356072101a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhashnode.html">hashnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50ed8c7958ea9b7b71242a356072101a">new_hashnode</a> (int key, int value)</td></tr>
<tr class="memdesc:a50ed8c7958ea9b7b71242a356072101a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a new hashnode with the specified key and value.  <br /></td></tr>
<tr class="memitem:aebeb41bb5b9cbc4de49a9462cbadbdf9" id="r_aebeb41bb5b9cbc4de49a9462cbadbdf9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebeb41bb5b9cbc4de49a9462cbadbdf9">hash</a> (int key)</td></tr>
<tr class="memdesc:aebeb41bb5b9cbc4de49a9462cbadbdf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hash index for a given key.  <br /></td></tr>
<tr class="memitem:a69dd8e980eb28c2e21280c9be00864bf" id="r_a69dd8e980eb28c2e21280c9be00864bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhashtable.html">hashtable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69dd8e980eb28c2e21280c9be00864bf">new_hashtable</a> (int size)</td></tr>
<tr class="memdesc:a69dd8e980eb28c2e21280c9be00864bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new hash table with a specified size.  <br /></td></tr>
<tr class="memitem:a214cac7811e02fb6348f1aced3d4d874" id="r_a214cac7811e02fb6348f1aced3d4d874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhashnode.html">hashnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a214cac7811e02fb6348f1aced3d4d874">search</a> (<a class="el" href="structhashtable.html">hashtable</a> *ht, int key)</td></tr>
<tr class="memdesc:a214cac7811e02fb6348f1aced3d4d874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a hashnode with a specified key in the hash table.  <br /></td></tr>
<tr class="memitem:ade9ca75fe5f70b0e7be013acac97e4ec" id="r_ade9ca75fe5f70b0e7be013acac97e4ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade9ca75fe5f70b0e7be013acac97e4ec">insert</a> (<a class="el" href="structhashtable.html">hashtable</a> *ht, <a class="el" href="structhashnode.html">hashnode</a> *hn)</td></tr>
<tr class="memdesc:ade9ca75fe5f70b0e7be013acac97e4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new hashnode into the hash table using linear probing.  <br /></td></tr>
<tr class="memitem:ae25a0f443d4ef78637925250a8759db2" id="r_ae25a0f443d4ef78637925250a8759db2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae25a0f443d4ef78637925250a8759db2">delete</a> (<a class="el" href="structhashtable.html">hashtable</a> *ht, int key)</td></tr>
<tr class="memdesc:ae25a0f443d4ef78637925250a8759db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a hashnode from the hash table by key using linear probing.  <br /></td></tr>
<tr class="memitem:acb4b8d24cce943fcaeb96d56199054ea" id="r_acb4b8d24cce943fcaeb96d56199054ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb4b8d24cce943fcaeb96d56199054ea">display</a> (<a class="el" href="structhashtable.html">hashtable</a> *ht)</td></tr>
<tr class="memdesc:acb4b8d24cce943fcaeb96d56199054ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the contents of the hash table.  <br /></td></tr>
<tr class="memitem:a43b16e69d5b2f4261314b078407e8b72" id="r_a43b16e69d5b2f4261314b078407e8b72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43b16e69d5b2f4261314b078407e8b72">clean</a> (<a class="el" href="structhashtable.html">hashtable</a> *ht)</td></tr>
<tr class="memdesc:a43b16e69d5b2f4261314b078407e8b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all memory allocated for the hash table and its elements.  <br /></td></tr>
<tr class="memitem:ae66f6b31b5ad750f1fe042a706a4e3d4" id="r_ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> ()</td></tr>
<tr class="memdesc:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Demonstrates usage of a simple hash table with open addressing.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Code example for CP264 Data Structures II - Array hash table with linear probing for collision handling. </p>
<dl class="section author"><dt>Author</dt><dd>HBF </dd></dl>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a43b16e69d5b2f4261314b078407e8b72" name="a43b16e69d5b2f4261314b078407e8b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b16e69d5b2f4261314b078407e8b72">&#9670;&#160;</a></span>clean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhashtable.html">hashtable</a> *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees all memory allocated for the hash table and its elements. </p>
<p>This function iterates through the hash table, frees each allocated hashnode, then frees the array of pointers, and finally frees the hashtable structure itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>Pointer to the hash table to be cleaned and freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae25a0f443d4ef78637925250a8759db2" name="ae25a0f443d4ef78637925250a8759db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25a0f443d4ef78637925250a8759db2">&#9670;&#160;</a></span>delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhashtable.html">hashtable</a> *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a hashnode from the hash table by key using linear probing. </p>
<p>This function searches for the node with the specified key in the hash table. If found, it marks the node as deleted by setting its key to -1 (tombstone) and decrements the element count. Linear probing is used to handle collisions during the search.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>Pointer to the hash table. </td></tr>
    <tr><td class="paramname">key</td><td>The key of the node to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Returns 1 if deletion was successful (node found and marked deleted), otherwise returns 0 if the key was not found. </dd></dl>

</div>
</div>
<a id="acb4b8d24cce943fcaeb96d56199054ea" name="acb4b8d24cce943fcaeb96d56199054ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4b8d24cce943fcaeb96d56199054ea">&#9670;&#160;</a></span>display()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void display </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhashtable.html">hashtable</a> *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the contents of the hash table. </p>
<p>This function iterates through the hash table's internal array and prints each index along with the key and value stored at that position, if any. Deleted entries (marked with key = -1) and empty slots (NULL) are also indicated appropriately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>Pointer to the hash table to be displayed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebeb41bb5b9cbc4de49a9462cbadbdf9" name="aebeb41bb5b9cbc4de49a9462cbadbdf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebeb41bb5b9cbc4de49a9462cbadbdf9">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hash </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the hash index for a given key. </p>
<p>This function uses the modulo operator to map the integer key to a valid index within the hash table size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The integer key to be hashed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index in the hash table corresponding to the key. </dd></dl>

</div>
</div>
<a id="ade9ca75fe5f70b0e7be013acac97e4ec" name="ade9ca75fe5f70b0e7be013acac97e4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9ca75fe5f70b0e7be013acac97e4ec">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhashtable.html">hashtable</a> *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhashnode.html">hashnode</a> *</td>          <td class="paramname"><span class="paramname"><em>hn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new hashnode into the hash table using linear probing. </p>
<p>This function inserts the given hashnode into the hash table. It first checks if the table is full. If not, it uses the hash function to find the initial index and then probes linearly to find an empty or deleted slot (marked by key == -1). The new node is placed at the found position, and the count is incremented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>Pointer to the hash table. </td></tr>
    <tr><td class="paramname">hn</td><td>Pointer to the hashnode to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae66f6b31b5ad750f1fe042a706a4e3d4" name="ae66f6b31b5ad750f1fe042a706a4e3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66f6b31b5ad750f1fe042a706a4e3d4">&#9670;&#160;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Demonstrates usage of a simple hash table with open addressing. </p>
<p>This function creates a static hash table of fixed size, inserts several key-value pairs, displays the contents, searches for a specific key, deletes that key if found, and then displays the contents again. Finally, it cleans up any allocated memory.</p>
<dl class="section return"><dt>Returns</dt><dd>int Returns 0 on successful execution. </dd></dl>

</div>
</div>
<a id="a50ed8c7958ea9b7b71242a356072101a" name="a50ed8c7958ea9b7b71242a356072101a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ed8c7958ea9b7b71242a356072101a">&#9670;&#160;</a></span>new_hashnode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhashnode.html">hashnode</a> * new_hashnode </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and initializes a new hashnode with the specified key and value. </p>
<p>Allocates memory for a new hashnode, sets its key and value fields, and returns a pointer to the newly created node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The integer key to store in the node. </td></tr>
    <tr><td class="paramname">value</td><td>The integer value associated with the key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly allocated hashnode. Returns NULL if memory allocation fails. </dd></dl>

</div>
</div>
<a id="a69dd8e980eb28c2e21280c9be00864bf" name="a69dd8e980eb28c2e21280c9be00864bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69dd8e980eb28c2e21280c9be00864bf">&#9670;&#160;</a></span>new_hashtable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhashtable.html">hashtable</a> * new_hashtable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new hash table with a specified size. </p>
<p>This function dynamically allocates memory for a hashtable structure and initializes an array of hashnode pointers to NULL. It also sets the size and count properties of the hash table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of buckets (array size) in the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly created hashtable. </dd></dl>

</div>
</div>
<a id="a214cac7811e02fb6348f1aced3d4d874" name="a214cac7811e02fb6348f1aced3d4d874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214cac7811e02fb6348f1aced3d4d874">&#9670;&#160;</a></span>search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhashnode.html">hashnode</a> * search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhashtable.html">hashtable</a> *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for a hashnode with a specified key in the hash table. </p>
<p>This function uses linear probing to find the hashnode with the given key. It starts at the index computed by the hash function and moves sequentially, wrapping around the table if necessary, until it finds the key or an empty slot.</p>
<p>Deleted nodes are marked with key == -1 and are skipped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>Pointer to the hash table. </td></tr>
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the hashnode containing the key, or NULL if not found. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="simple__hash_8c.html">simple_hash.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
