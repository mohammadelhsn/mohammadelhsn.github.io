<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: expression_tree_more.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('expression__tree__more_8c.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">expression_tree_more.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:ledata" id="r_ledata"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionledata.html">ledata</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union representing a leaf element for expression trees.  <a href="unionledata.html#details">More...</a><br /></td></tr>
<tr class="memitem:tree_5Fnode" id="r_tree_5Fnode"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtree__node.html">tree_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing a node in an expression tree.  <a href="structtree__node.html#details">More...</a><br /></td></tr>
<tr class="memitem:node" id="r_node"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnode.html">node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node structure for singly linked list used in infix to postfix conversion and expression tree operations.  <a href="structnode.html#details">More...</a><br /></td></tr>
<tr class="memitem:stnode" id="r_stnode"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstnode.html">stnode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack node structure for expression tree construction from postfix queue.  <a href="structstnode.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af6336927492f2968d66455c98203e33c" id="r_af6336927492f2968d66455c98203e33c"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="unionledata.html">ledata</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6336927492f2968d66455c98203e33c">DATA</a></td></tr>
<tr class="memdesc:af6336927492f2968d66455c98203e33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union representing a leaf element for expression trees.  <br /></td></tr>
<tr class="memitem:a3c7f09d468096f99279b82d4866895c7" id="r_a3c7f09d468096f99279b82d4866895c7"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structtree__node.html">tree_node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c7f09d468096f99279b82d4866895c7">tnode</a></td></tr>
<tr class="memdesc:a3c7f09d468096f99279b82d4866895c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing a node in an expression tree.  <br /></td></tr>
<tr class="memitem:ac821bb6650fba4b70984699e387af551" id="r_ac821bb6650fba4b70984699e387af551"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structnode.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a></td></tr>
<tr class="memdesc:ac821bb6650fba4b70984699e387af551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node structure for singly linked list used in infix to postfix conversion and expression tree operations.  <br /></td></tr>
<tr class="memitem:aac07d042ec52729fd6f1dc0220352688" id="r_aac07d042ec52729fd6f1dc0220352688"><td class="memItemLeft" align="right" valign="top">typedef struct stnode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac07d042ec52729fd6f1dc0220352688">stnode</a></td></tr>
<tr class="memdesc:aac07d042ec52729fd6f1dc0220352688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack node structure for expression tree construction from postfix queue.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afaba07c5fc18eb7a3ed251c530371345" id="r_afaba07c5fc18eb7a3ed251c530371345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afaba07c5fc18eb7a3ed251c530371345">new_tnode</a> (int data, int type)</td></tr>
<tr class="memdesc:afaba07c5fc18eb7a3ed251c530371345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new tree node with the specified data and type.  <br /></td></tr>
<tr class="memitem:ae1210b0815994061b567d017da533264" id="r_ae1210b0815994061b567d017da533264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1210b0815994061b567d017da533264">print_tree</a> (<a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> *root, int space)</td></tr>
<tr class="memitem:ac5889882ca2c2c4ec2abcb501f368d4e" id="r_ac5889882ca2c2c4ec2abcb501f368d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5889882ca2c2c4ec2abcb501f368d4e">print_infix</a> (<a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> *root)</td></tr>
<tr class="memitem:aa7090803bc4b8861be8a4c63bab056a7" id="r_aa7090803bc4b8861be8a4c63bab056a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7090803bc4b8861be8a4c63bab056a7">print_prefix</a> (<a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> *root)</td></tr>
<tr class="memitem:adf59f1a02ba00fc469ce7032c7417142" id="r_adf59f1a02ba00fc469ce7032c7417142"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf59f1a02ba00fc469ce7032c7417142">print_postfix</a> (<a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> *root)</td></tr>
<tr class="memitem:a1a8e76ba4ac18c2cd08089e9b4052261" id="r_a1a8e76ba4ac18c2cd08089e9b4052261"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a8e76ba4ac18c2cd08089e9b4052261">clean_tree</a> (<a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> **rootp)</td></tr>
<tr class="memdesc:a1a8e76ba4ac18c2cd08089e9b4052261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively deallocates all nodes in a binary tree and sets the root pointer to NULL.  <br /></td></tr>
<tr class="memitem:a2a44cc269ed4069e9b9897e3b1b263c1" id="r_a2a44cc269ed4069e9b9897e3b1b263c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a44cc269ed4069e9b9897e3b1b263c1">evaluate_expression_tree</a> (<a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> *root)</td></tr>
<tr class="memitem:a15d54060abe5fb72618bd844ab272f0c" id="r_a15d54060abe5fb72618bd844ab272f0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15d54060abe5fb72618bd844ab272f0c">new_sqnode</a> (<a class="el" href="expression__tree_8c.html#af6336927492f2968d66455c98203e33c">DATA</a> data, int type)</td></tr>
<tr class="memitem:af07f8a53745735f98e7cc120e65c37bc" id="r_af07f8a53745735f98e7cc120e65c37bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af07f8a53745735f98e7cc120e65c37bc">display_forward</a> (<a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> *start)</td></tr>
<tr class="memdesc:af07f8a53745735f98e7cc120e65c37bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the elements of a singly linked queue in forward order.  <br /></td></tr>
<tr class="memitem:a8c973601437d6ff50ab25d80f30710e3" id="r_a8c973601437d6ff50ab25d80f30710e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c973601437d6ff50ab25d80f30710e3">clean</a> (<a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **startp)</td></tr>
<tr class="memdesc:a8c973601437d6ff50ab25d80f30710e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all nodes in a singly linked queue starting from the given pointer.  <br /></td></tr>
<tr class="memitem:ae257c04bd195114485a4cdebcb420094" id="r_ae257c04bd195114485a4cdebcb420094"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae257c04bd195114485a4cdebcb420094">dequeue</a> (<a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **frontp, <a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **rearp)</td></tr>
<tr class="memitem:a20772b145da4d85e676e66128bc800f6" id="r_a20772b145da4d85e676e66128bc800f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20772b145da4d85e676e66128bc800f6">enqueue</a> (<a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **frontp, <a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **rearp, <a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> *np)</td></tr>
<tr class="memdesc:a20772b145da4d85e676e66128bc800f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new node to the end of the queue.  <br /></td></tr>
<tr class="memitem:aaf3848f2e920c3cb42514f9060f70ffc" id="r_aaf3848f2e920c3cb42514f9060f70ffc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf3848f2e920c3cb42514f9060f70ffc">push</a> (<a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **topp, <a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> *np)</td></tr>
<tr class="memitem:a073830ed14a152a0abd54ccf0d377199" id="r_a073830ed14a152a0abd54ccf0d377199"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a073830ed14a152a0abd54ccf0d377199">pop</a> (<a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **topp)</td></tr>
<tr class="memitem:a768ba14fc4a85cf436915d1e33b6eac8" id="r_a768ba14fc4a85cf436915d1e33b6eac8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a768ba14fc4a85cf436915d1e33b6eac8">infix_to_postfix</a> (char *infixstr, <a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **frontp, <a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **rearp)</td></tr>
<tr class="memitem:a6b7154e6de2ba8156ec8e4388f0be139" id="r_a6b7154e6de2ba8156ec8e4388f0be139"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b7154e6de2ba8156ec8e4388f0be139">evaluate_postfix</a> (<a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **frontp, <a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **rearp)</td></tr>
<tr class="memitem:a857e6fe3ae4e31e051d0b6646375c7b4" id="r_a857e6fe3ae4e31e051d0b6646375c7b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a857e6fe3ae4e31e051d0b6646375c7b4">get_priority</a> (char opr)</td></tr>
<tr class="memitem:aeb955ef8744de2a55f4b58789b33cf24" id="r_aeb955ef8744de2a55f4b58789b33cf24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb955ef8744de2a55f4b58789b33cf24">is_operator</a> (char op)</td></tr>
<tr class="memitem:adb1f5d88581a6feb724f3884f3bdfd4c" id="r_adb1f5d88581a6feb724f3884f3bdfd4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb1f5d88581a6feb724f3884f3bdfd4c">is_symbol</a> (char s)</td></tr>
<tr class="memitem:abf463c1315fa1a76c9764097cf370aca" id="r_abf463c1315fa1a76c9764097cf370aca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf463c1315fa1a76c9764097cf370aca">tpush</a> (<a class="el" href="structstnode.html">stnode</a> **topp, <a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> *tnp)</td></tr>
<tr class="memitem:aefedacea64981741428ece9bd23e948f" id="r_aefedacea64981741428ece9bd23e948f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefedacea64981741428ece9bd23e948f">tpop</a> (<a class="el" href="structstnode.html">stnode</a> **topp)</td></tr>
<tr class="memitem:a7772812ced7378858ed5f81081833c1e" id="r_a7772812ced7378858ed5f81081833c1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7772812ced7378858ed5f81081833c1e">postfix_to_expression_tree</a> (<a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> *front)</td></tr>
<tr class="memitem:ab3addc69f75e14e2f864b804fcf3c0f9" id="r_ab3addc69f75e14e2f864b804fcf3c0f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3addc69f75e14e2f864b804fcf3c0f9">expression_tree_to_prefix</a> (<a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> *root, <a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **frontp, <a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **rearp)</td></tr>
<tr class="memitem:a70df5aaf699fd18a751c2bf14e5d0926" id="r_a70df5aaf699fd18a751c2bf14e5d0926"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70df5aaf699fd18a751c2bf14e5d0926">evaluate_prefix</a> (<a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> *front)</td></tr>
<tr class="memitem:ae66f6b31b5ad750f1fe042a706a4e3d4" id="r_ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> ()</td></tr>
<tr class="memdesc:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point of the program.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>infix -&gt; postfix (singly linked list) postfix -&gt; expression tree -&gt; infix, postfix, prefix, prefix evaluation expression tree -&gt; infix, postfix, prefix, prefix evaluation </p><dl class="section author"><dt>Author</dt><dd>HBF </dd></dl>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="af6336927492f2968d66455c98203e33c" name="af6336927492f2968d66455c98203e33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6336927492f2968d66455c98203e33c">&#9670;&#160;</a></span>DATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="unionledata.html">ledata</a> <a class="el" href="expression__tree_8c.html#af6336927492f2968d66455c98203e33c">DATA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Union representing a leaf element for expression trees. </p>
<p>operant {int} - Integer operand value. operator {char} - Operator character. parenthesis {char} - Parenthesis character. </p>

</div>
</div>
<a id="ac821bb6650fba4b70984699e387af551" name="ac821bb6650fba4b70984699e387af551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac821bb6650fba4b70984699e387af551">&#9670;&#160;</a></span>sqnode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structnode.html">node</a> <a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node structure for singly linked list used in infix to postfix conversion and expression tree operations. </p>
<p>data {<a class="el" href="expression__tree_8c.html#af6336927492f2968d66455c98203e33c" title="Union representing a leaf element for expression trees.">DATA</a>} - Operand, operator, or parenthesis stored in the node. type {int} - 0: operand; 1: operator; 2: parenthesis. next {*node} - Pointer to the next node in the list. </p>

</div>
</div>
<a id="aac07d042ec52729fd6f1dc0220352688" name="aac07d042ec52729fd6f1dc0220352688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac07d042ec52729fd6f1dc0220352688">&#9670;&#160;</a></span>stnode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct stnode stnode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stack node structure for expression tree construction from postfix queue. </p>
<p>tnp {*tnode} - Pointer to a tree node. next {*stnode} - Pointer to the next stack node. </p>

</div>
</div>
<a id="a3c7f09d468096f99279b82d4866895c7" name="a3c7f09d468096f99279b82d4866895c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7f09d468096f99279b82d4866895c7">&#9670;&#160;</a></span>tnode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structtree__node.html">tree_node</a> <a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure representing a node in an expression tree. </p>
<p>data {<a class="el" href="expression__tree_8c.html#af6336927492f2968d66455c98203e33c" title="Union representing a leaf element for expression trees.">DATA</a>} - Operand, operator, or parenthesis stored in the node. type {int} - 0: operand; 1: operator; 2: parenthesis. left {*tree_node} - Pointer to the left child. right {*tree_node} - Pointer to the right child. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a8c973601437d6ff50ab25d80f30710e3" name="a8c973601437d6ff50ab25d80f30710e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c973601437d6ff50ab25d80f30710e3">&#9670;&#160;</a></span>clean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **</td>          <td class="paramname"><span class="paramname"><em>startp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees all nodes in a singly linked queue starting from the given pointer. </p>
<p>This function traverses the queue starting from the node pointed to by *startp, deallocates all nodes, and sets *startp to NULL to prevent dangling pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startp</td><td>Double pointer to the head of the singly linked queue (sqnode). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a8e76ba4ac18c2cd08089e9b4052261" name="a1a8e76ba4ac18c2cd08089e9b4052261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8e76ba4ac18c2cd08089e9b4052261">&#9670;&#160;</a></span>clean_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clean_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> **</td>          <td class="paramname"><span class="paramname"><em>rootp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively deallocates all nodes in a binary tree and sets the root pointer to NULL. </p>
<p>This function traverses the binary tree rooted at *rootp, frees all allocated memory for the nodes, and sets the pointer referenced by rootp to NULL to prevent dangling pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rootp</td><td>Double pointer to the root node of the tree to be cleaned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae257c04bd195114485a4cdebcb420094" name="ae257c04bd195114485a4cdebcb420094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae257c04bd195114485a4cdebcb420094">&#9670;&#160;</a></span>dequeue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> * dequeue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **</td>          <td class="paramname"><span class="paramname"><em>frontp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **</td>          <td class="paramname"><span class="paramname"><em>rearp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dequeues a node from the front of a queue implemented using pointers to sqnode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frontp</td><td>Pointer to the pointer of the front node of the queue. </td></tr>
    <tr><td class="paramname">rearp</td><td>Pointer to the pointer of the rear node of the queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the dequeued sqnode, or NULL if the queue is empty.</dd></dl>
<p>This function removes and returns the node at the front of the queue. It updates the front and rear pointers as necessary. </p>

</div>
</div>
<a id="af07f8a53745735f98e7cc120e65c37bc" name="af07f8a53745735f98e7cc120e65c37bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07f8a53745735f98e7cc120e65c37bc">&#9670;&#160;</a></span>display_forward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void display_forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> *</td>          <td class="paramname"><span class="paramname"><em>start</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the elements of a singly linked queue in forward order. </p>
<p>This function traverses the queue starting from the given node and prints or processes each element in the order they appear in the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Pointer to the first node of the queue to be displayed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20772b145da4d85e676e66128bc800f6" name="a20772b145da4d85e676e66128bc800f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20772b145da4d85e676e66128bc800f6">&#9670;&#160;</a></span>enqueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **</td>          <td class="paramname"><span class="paramname"><em>frontp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **</td>          <td class="paramname"><span class="paramname"><em>rearp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> *</td>          <td class="paramname"><span class="paramname"><em>np</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new node to the end of the queue. </p>
<p>This function enqueues the given node pointer <span class="tt">np</span> to the queue represented by the front and rear pointers <span class="tt">frontp</span> and <span class="tt">rearp</span>. The queue is implemented as a linked list of <span class="tt">sqnode</span> structures. After the operation, the queue will contain the new node at its rear.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frontp</td><td>Pointer to the pointer to the front node of the queue. </td></tr>
    <tr><td class="paramname">rearp</td><td>Pointer to the pointer to the rear node of the queue. </td></tr>
    <tr><td class="paramname">np</td><td>Pointer to the node to be enqueued. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a44cc269ed4069e9b9897e3b1b263c1" name="a2a44cc269ed4069e9b9897e3b1b263c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a44cc269ed4069e9b9897e3b1b263c1">&#9670;&#160;</a></span>evaluate_expression_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evaluate_expression_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluates the value of an arithmetic expression represented by a binary expression tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root node of the expression tree. Each node may represent an operator (e.g., '+', '-', '*', '/') or an operand (integer value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integer result of evaluating the expression tree. If the tree is empty, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a6b7154e6de2ba8156ec8e4388f0be139" name="a6b7154e6de2ba8156ec8e4388f0be139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7154e6de2ba8156ec8e4388f0be139">&#9670;&#160;</a></span>evaluate_postfix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evaluate_postfix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **</td>          <td class="paramname"><span class="paramname"><em>frontp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **</td>          <td class="paramname"><span class="paramname"><em>rearp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluates a postfix (Reverse Polish Notation) expression represented by a queue.</p>
<p>This function processes the queue of tokens (operands and operators) pointed to by 'frontp' and 'rearp', computes the result of the postfix expression, and returns it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frontp</td><td>Pointer to the front pointer of the queue containing the postfix expression. </td></tr>
    <tr><td class="paramname">rearp</td><td>Pointer to the rear pointer of the queue containing the postfix expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integer result of evaluating the postfix expression. </dd></dl>

</div>
</div>
<a id="a70df5aaf699fd18a751c2bf14e5d0926" name="a70df5aaf699fd18a751c2bf14e5d0926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70df5aaf699fd18a751c2bf14e5d0926">&#9670;&#160;</a></span>evaluate_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evaluate_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> *</td>          <td class="paramname"><span class="paramname"><em>front</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluates an arithmetic expression represented in prefix notation using a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td>Pointer to the front node of the queue containing the prefix expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integer result of evaluating the prefix expression. </dd></dl>

</div>
</div>
<a id="ab3addc69f75e14e2f864b804fcf3c0f9" name="ab3addc69f75e14e2f864b804fcf3c0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3addc69f75e14e2f864b804fcf3c0f9">&#9670;&#160;</a></span>expression_tree_to_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void expression_tree_to_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **</td>          <td class="paramname"><span class="paramname"><em>frontp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **</td>          <td class="paramname"><span class="paramname"><em>rearp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts an expression tree to its prefix (Polish) notation and stores the result in a queue.</p>
<p>This function traverses the given expression tree in pre-order (root, left, right) and enqueues each node's value into a queue represented by frontp and rearp pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root node of the expression tree (tnode). </td></tr>
    <tr><td class="paramname">frontp</td><td>Double pointer to the front of the output queue (sqnode **). </td></tr>
    <tr><td class="paramname">rearp</td><td>Double pointer to the rear of the output queue (sqnode **). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a857e6fe3ae4e31e051d0b6646375c7b4" name="a857e6fe3ae4e31e051d0b6646375c7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857e6fe3ae4e31e051d0b6646375c7b4">&#9670;&#160;</a></span>get_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int get_priority </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>opr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the priority (precedence) of the given operator character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opr</td><td>The operator character (e.g., '+', '-', '*', '/'). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer representing the precedence of the operator. Higher values indicate higher precedence. </dd></dl>

</div>
</div>
<a id="a768ba14fc4a85cf436915d1e33b6eac8" name="a768ba14fc4a85cf436915d1e33b6eac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768ba14fc4a85cf436915d1e33b6eac8">&#9670;&#160;</a></span>infix_to_postfix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void infix_to_postfix </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>infixstr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **</td>          <td class="paramname"><span class="paramname"><em>frontp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **</td>          <td class="paramname"><span class="paramname"><em>rearp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts an infix expression string to its postfix (Reverse Polish Notation) form.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">infixstr</td><td>The input string containing the infix expression. </td></tr>
    <tr><td class="paramname">frontp</td><td>Pointer to the front pointer of the output queue (postfix expression). </td></tr>
    <tr><td class="paramname">rearp</td><td>Pointer to the rear pointer of the output queue (postfix expression).</td></tr>
  </table>
  </dd>
</dl>
<p>This function parses the given infix expression and enqueues the resulting postfix tokens into a queue represented by frontp and rearp. The queue nodes are of type sqnode. </p>

</div>
</div>
<a id="aeb955ef8744de2a55f4b58789b33cf24" name="aeb955ef8744de2a55f4b58789b33cf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb955ef8744de2a55f4b58789b33cf24">&#9670;&#160;</a></span>is_operator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_operator </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the given character is a valid operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The character to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if the character is an operator (e.g., '+', '-', '*', '/'), otherwise returns 0. </dd></dl>

</div>
</div>
<a id="adb1f5d88581a6feb724f3884f3bdfd4c" name="adb1f5d88581a6feb724f3884f3bdfd4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1f5d88581a6feb724f3884f3bdfd4c">&#9670;&#160;</a></span>is_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_symbol </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the given character is a valid symbol (e.g., operator or operand) used in an expression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The character to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the character is a symbol, zero otherwise. </dd></dl>

</div>
</div>
<a id="ae66f6b31b5ad750f1fe042a706a4e3d4" name="ae66f6b31b5ad750f1fe042a706a4e3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66f6b31b5ad750f1fe042a706a4e3d4">&#9670;&#160;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point of the program. </p>
<p>This function serves as the main entry point for the application. It is responsible for initializing the program, executing the core logic, and handling the program's termination.</p>
<dl class="section return"><dt>Returns</dt><dd>int Returns 0 upon successful completion, or a non-zero value if an error occurs. </dd></dl>

</div>
</div>
<a id="a15d54060abe5fb72618bd844ab272f0c" name="a15d54060abe5fb72618bd844ab272f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d54060abe5fb72618bd844ab272f0c">&#9670;&#160;</a></span>new_sqnode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> * new_sqnode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="expression__tree_8c.html#af6336927492f2968d66455c98203e33c">DATA</a></td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new stack queue node with the specified data and type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be stored in the new node. </td></tr>
    <tr><td class="paramname">type</td><td>An integer representing the type of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created sqnode. </dd></dl>

</div>
</div>
<a id="afaba07c5fc18eb7a3ed251c530371345" name="afaba07c5fc18eb7a3ed251c530371345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaba07c5fc18eb7a3ed251c530371345">&#9670;&#160;</a></span>new_tnode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> * new_tnode </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new tree node with the specified data and type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The value to store in the node. </td></tr>
    <tr><td class="paramname">type</td><td>The type indicator for the node (e.g., operator or operand). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly created tnode, or NULL if memory allocation fails. </dd></dl>

</div>
</div>
<a id="a073830ed14a152a0abd54ccf0d377199" name="a073830ed14a152a0abd54ccf0d377199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073830ed14a152a0abd54ccf0d377199">&#9670;&#160;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> * pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **</td>          <td class="paramname"><span class="paramname"><em>topp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pops the top node from the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topp</td><td>A double pointer to the top of the stack (sqnode **). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the popped sqnode, or NULL if the stack is empty. </dd></dl>

</div>
</div>
<a id="a7772812ced7378858ed5f81081833c1e" name="a7772812ced7378858ed5f81081833c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7772812ced7378858ed5f81081833c1e">&#9670;&#160;</a></span>postfix_to_expression_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> * postfix_to_expression_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> *</td>          <td class="paramname"><span class="paramname"><em>front</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a postfix expression, represented as a queue of nodes, into an expression tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front</td><td>Pointer to the front of the queue containing the postfix expression (sqnode*). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the root node of the constructed expression tree (tnode*).</dd></dl>
<p>The function processes the postfix expression and builds a binary expression tree, where each internal node represents an operator and each leaf node represents an operand. </p>

</div>
</div>
<a id="ac5889882ca2c2c4ec2abcb501f368d4e" name="ac5889882ca2c2c4ec2abcb501f368d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5889882ca2c2c4ec2abcb501f368d4e">&#9670;&#160;</a></span>print_infix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_infix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the infix expression represented by the binary expression tree rooted at 'root'. The function traverses the tree in infix order and outputs the expression with appropriate parentheses to preserve the correct order of operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root node of the expression tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf59f1a02ba00fc469ce7032c7417142" name="adf59f1a02ba00fc469ce7032c7417142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf59f1a02ba00fc469ce7032c7417142">&#9670;&#160;</a></span>print_postfix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_postfix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the postfix (Reverse Polish Notation) representation of the expression tree.</p>
<p>Traverses the binary expression tree rooted at 'root' in post-order and prints each node's value, resulting in a postfix expression output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root node of the expression tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7090803bc4b8861be8a4c63bab056a7" name="aa7090803bc4b8861be8a4c63bab056a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7090803bc4b8861be8a4c63bab056a7">&#9670;&#160;</a></span>print_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the prefix (Polish) notation of the expression tree rooted at the given node.</p>
<p>This function traverses the binary expression tree in pre-order (root, left, right) and prints each node's value, resulting in a prefix representation of the expression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root node of the expression tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1210b0815994061b567d017da533264" name="ae1210b0815994061b567d017da533264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1210b0815994061b567d017da533264">&#9670;&#160;</a></span>print_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>space</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a visual representation of a binary tree structure to the console.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root node of the tree to be printed. </td></tr>
    <tr><td class="paramname">space</td><td>The current indentation level (number of spaces) used for formatting the output.</td></tr>
  </table>
  </dd>
</dl>
<p>This function recursively traverses the tree and prints each node in a structured format, visually representing the tree hierarchy. The 'space' parameter controls the indentation for each level of the tree. </p>

</div>
</div>
<a id="aaf3848f2e920c3cb42514f9060f70ffc" name="aaf3848f2e920c3cb42514f9060f70ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3848f2e920c3cb42514f9060f70ffc">&#9670;&#160;</a></span>push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> **</td>          <td class="paramname"><span class="paramname"><em>topp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac821bb6650fba4b70984699e387af551">sqnode</a> *</td>          <td class="paramname"><span class="paramname"><em>np</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pushes a node onto the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topp</td><td>Double pointer to the top of the stack. </td></tr>
    <tr><td class="paramname">np</td><td>Pointer to the node to be pushed onto the stack. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefedacea64981741428ece9bd23e948f" name="aefedacea64981741428ece9bd23e948f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefedacea64981741428ece9bd23e948f">&#9670;&#160;</a></span>tpop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> * tpop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstnode.html">stnode</a> **</td>          <td class="paramname"><span class="paramname"><em>topp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pops the top node from the stack of tree nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topp</td><td>A double pointer to the top of the stack (pointer to stack top pointer). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the popped tree node, or NULL if the stack is empty. </dd></dl>

</div>
</div>
<a id="abf463c1315fa1a76c9764097cf370aca" name="abf463c1315fa1a76c9764097cf370aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf463c1315fa1a76c9764097cf370aca">&#9670;&#160;</a></span>tpush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tpush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstnode.html">stnode</a> **</td>          <td class="paramname"><span class="paramname"><em>topp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="expression__tree_8c.html#a3c7f09d468096f99279b82d4866895c7">tnode</a> *</td>          <td class="paramname"><span class="paramname"><em>tnp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pushes a tree node pointer onto the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topp</td><td>Double pointer to the top of the stack (stack of tree node pointers). </td></tr>
    <tr><td class="paramname">tnp</td><td>Pointer to the tree node to be pushed onto the stack. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="expression__tree__more_8c.html">expression_tree_more.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
