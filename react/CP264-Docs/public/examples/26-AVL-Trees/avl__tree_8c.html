<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: avl_tree.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('avl__tree_8c.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">avl_tree.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Code example for CP264 Data Structures II - AVL tree insert and delete operations, using recursive algorithms,.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:node" id="r_node"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnode.html">node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing a node in an AVL tree with parent pointer.  <a href="structnode.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab7767888cfea8af07851e50456e4e0d8" id="r_ab7767888cfea8af07851e50456e4e0d8"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structnode.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7767888cfea8af07851e50456e4e0d8">tnode</a></td></tr>
<tr class="memdesc:ab7767888cfea8af07851e50456e4e0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define node structure for an AVL tree.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a10c2ad0043c53c1ce457fb120626c907" id="r_a10c2ad0043c53c1ce457fb120626c907"><td class="memItemLeft" align="right" valign="top"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10c2ad0043c53c1ce457fb120626c907">new_node</a> (int key)</td></tr>
<tr class="memdesc:a10c2ad0043c53c1ce457fb120626c907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new AVL tree node with the specified key.  <br /></td></tr>
<tr class="memitem:ad85f111f1681b6b9f73530c712e14c45" id="r_ad85f111f1681b6b9f73530c712e14c45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad85f111f1681b6b9f73530c712e14c45">print_preorder</a> (<a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *root)</td></tr>
<tr class="memdesc:ad85f111f1681b6b9f73530c712e14c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the nodes of an AVL tree in preorder traversal.  <br /></td></tr>
<tr class="memitem:a36b292f4117a281cf5a25b509b56d235" id="r_a36b292f4117a281cf5a25b509b56d235"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36b292f4117a281cf5a25b509b56d235">print_inorder</a> (<a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *root)</td></tr>
<tr class="memdesc:a36b292f4117a281cf5a25b509b56d235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the nodes of an AVL tree in inorder traversal.  <br /></td></tr>
<tr class="memitem:aae3b6273d0ef04b893ab10b21c64b1b2" id="r_aae3b6273d0ef04b893ab10b21c64b1b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae3b6273d0ef04b893ab10b21c64b1b2">print_tree</a> (<a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *root, int prelen)</td></tr>
<tr class="memdesc:aae3b6273d0ef04b893ab10b21c64b1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the structure of an AVL tree in a visually hierarchical format.  <br /></td></tr>
<tr class="memitem:a1f2a238d51d880f0c2f1f84270ad4f02" id="r_a1f2a238d51d880f0c2f1f84270ad4f02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f2a238d51d880f0c2f1f84270ad4f02">search</a> (<a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *tnp, int val)</td></tr>
<tr class="memdesc:a1f2a238d51d880f0c2f1f84270ad4f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a node with the specified value in the AVL tree.  <br /></td></tr>
<tr class="memitem:a078c52fc674fc34b00f340296349911e" id="r_a078c52fc674fc34b00f340296349911e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a078c52fc674fc34b00f340296349911e">insert</a> (<a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *root, int key)</td></tr>
<tr class="memdesc:a078c52fc674fc34b00f340296349911e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new node with the given key into the AVL tree.  <br /></td></tr>
<tr class="memitem:aaf86a1430703a13dad635dcabee33a9a" id="r_aaf86a1430703a13dad635dcabee33a9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf86a1430703a13dad635dcabee33a9a">delete</a> (<a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *root, int key)</td></tr>
<tr class="memdesc:aaf86a1430703a13dad635dcabee33a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a node with the specified key from the AVL tree.  <br /></td></tr>
<tr class="memitem:a1a8e76ba4ac18c2cd08089e9b4052261" id="r_a1a8e76ba4ac18c2cd08089e9b4052261"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a8e76ba4ac18c2cd08089e9b4052261">clean_tree</a> (<a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> **rootp)</td></tr>
<tr class="memdesc:a1a8e76ba4ac18c2cd08089e9b4052261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively deallocates all nodes in an AVL tree and sets the root pointer to NULL.  <br /></td></tr>
<tr class="memitem:a08d6d9f68171625e4c8e657bbf547eff" id="r_a08d6d9f68171625e4c8e657bbf547eff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08d6d9f68171625e4c8e657bbf547eff">get_smallest_node</a> (<a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *root)</td></tr>
<tr class="memdesc:a08d6d9f68171625e4c8e657bbf547eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the node with the smallest value in the AVL tree.  <br /></td></tr>
<tr class="memitem:af082905f7eac6d03e92015146bbc1925" id="r_af082905f7eac6d03e92015146bbc1925"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af082905f7eac6d03e92015146bbc1925">max</a> (int a, int b)</td></tr>
<tr class="memdesc:af082905f7eac6d03e92015146bbc1925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum of two integer values.  <br /></td></tr>
<tr class="memitem:a3dda4ff3fb91cfd6c99bb7052b819e51" id="r_a3dda4ff3fb91cfd6c99bb7052b819e51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dda4ff3fb91cfd6c99bb7052b819e51">height</a> (<a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *root)</td></tr>
<tr class="memdesc:a3dda4ff3fb91cfd6c99bb7052b819e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the height of an AVL tree.  <br /></td></tr>
<tr class="memitem:ab605122839c6c2e752001a093caea0d4" id="r_ab605122839c6c2e752001a093caea0d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab605122839c6c2e752001a093caea0d4">rotate_right</a> (<a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *y)</td></tr>
<tr class="memdesc:ab605122839c6c2e752001a093caea0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a right rotation on the given AVL tree node.  <br /></td></tr>
<tr class="memitem:ae740ee9786bbaab4a07f134d560ceccf" id="r_ae740ee9786bbaab4a07f134d560ceccf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae740ee9786bbaab4a07f134d560ceccf">rotate_left</a> (<a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *x)</td></tr>
<tr class="memdesc:ae740ee9786bbaab4a07f134d560ceccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotation on the given AVL tree node.  <br /></td></tr>
<tr class="memitem:a00d84abbc3284b6c849dce7edf23aa35" id="r_a00d84abbc3284b6c849dce7edf23aa35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00d84abbc3284b6c849dce7edf23aa35">balance_factor</a> (<a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *n)</td></tr>
<tr class="memdesc:a00d84abbc3284b6c849dce7edf23aa35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the balance factor of a given AVL tree node.  <br /></td></tr>
<tr class="memitem:aa1ec4daa44e5cfbe76a48d11b7ecc434" id="r_aa1ec4daa44e5cfbe76a48d11b7ecc434"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1ec4daa44e5cfbe76a48d11b7ecc434">is_avl</a> (<a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *root)</td></tr>
<tr class="memdesc:aa1ec4daa44e5cfbe76a48d11b7ecc434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a binary tree rooted at the given node is an AVL tree.  <br /></td></tr>
<tr class="memitem:ae66f6b31b5ad750f1fe042a706a4e3d4" id="r_ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> ()</td></tr>
<tr class="memdesc:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point of the program.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2fc5b8519891fef43c7520d7fde1056e" id="r_a2fc5b8519891fef43c7520d7fde1056e"><td class="memItemLeft" align="right" valign="top"><a id="a2fc5b8519891fef43c7520d7fde1056e" name="a2fc5b8519891fef43c7520d7fde1056e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>insert_tests</b> [] = {9, 6, 10, 0, 6, 11, -1, 1, 2}</td></tr>
<tr class="memitem:a74d67279ce8679ac2dadf153d35e03f6" id="r_a74d67279ce8679ac2dadf153d35e03f6"><td class="memItemLeft" align="right" valign="top"><a id="a74d67279ce8679ac2dadf153d35e03f6" name="a74d67279ce8679ac2dadf153d35e03f6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>search_tests</b> [] = {6, 4, 1}</td></tr>
<tr class="memitem:a8100f84df1aafbac13e3c4368130cbb5" id="r_a8100f84df1aafbac13e3c4368130cbb5"><td class="memItemLeft" align="right" valign="top"><a id="a8100f84df1aafbac13e3c4368130cbb5" name="a8100f84df1aafbac13e3c4368130cbb5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>delete_tests</b> [] = {10, 2, 1, 5, 11, -1, 6}</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Code example for CP264 Data Structures II - AVL tree insert and delete operations, using recursive algorithms,. </p>
<dl class="section author"><dt>Author</dt><dd>adapted from <a href="http://www.geeksforgeeks.org/avl-tree-set-2-deletion/">http://www.geeksforgeeks.org/avl-tree-set-2-deletion/</a> </dd>
<dd>
HBF </dd></dl>
<dl class="section version"><dt>Version</dt><dd>2025-03-08 </dd></dl>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ab7767888cfea8af07851e50456e4e0d8" name="ab7767888cfea8af07851e50456e4e0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7767888cfea8af07851e50456e4e0d8">&#9670;&#160;</a></span>tnode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structnode.html">node</a> <a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define node structure for an AVL tree. </p>
<p>key {int} - key value of the node height {int} - height of the node in the tree left {*node} - pointer to the left child right {*node} - pointer to the right child </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a00d84abbc3284b6c849dce7edf23aa35" name="a00d84abbc3284b6c849dce7edf23aa35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d84abbc3284b6c849dce7edf23aa35">&#9670;&#160;</a></span>balance_factor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int balance_factor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the balance factor of a given AVL tree node. </p>
<p>The balance factor is defined as the height difference between the left and right subtrees of the node. It is used to determine whether the node is balanced, left-heavy, or right-heavy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Pointer to the AVL tree node whose balance factor is to be calculated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int The balance factor of the node:<ul>
<li>Positive value if left subtree is taller,</li>
<li>Negative value if right subtree is taller,</li>
<li>Zero if both subtrees have the same height. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1a8e76ba4ac18c2cd08089e9b4052261" name="a1a8e76ba4ac18c2cd08089e9b4052261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8e76ba4ac18c2cd08089e9b4052261">&#9670;&#160;</a></span>clean_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clean_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> **</td>          <td class="paramname"><span class="paramname"><em>rootp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively deallocates all nodes in an AVL tree and sets the root pointer to NULL. </p>
<p>This function traverses the AVL tree rooted at the node pointed to by rootp, frees all allocated memory for the nodes, and sets the root pointer to NULL to prevent dangling references.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rootp</td><td>A double pointer to the root node of the AVL tree (tnode **). After the function returns, *rootp will be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf86a1430703a13dad635dcabee33a9a" name="aaf86a1430703a13dad635dcabee33a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf86a1430703a13dad635dcabee33a9a">&#9670;&#160;</a></span>delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> * delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a node with the specified key from the AVL tree. </p>
<p>This function removes the node containing the given key from the AVL tree rooted at 'root', rebalances the tree if necessary to maintain AVL properties, and returns the new root of the tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root node of the AVL tree. </td></tr>
    <tr><td class="paramname">key</td><td>The key value of the node to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tnode* Pointer to the new root node of the AVL tree after deletion. </dd></dl>

</div>
</div>
<a id="a08d6d9f68171625e4c8e657bbf547eff" name="a08d6d9f68171625e4c8e657bbf547eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d6d9f68171625e4c8e657bbf547eff">&#9670;&#160;</a></span>get_smallest_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> * get_smallest_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the node with the smallest value in the AVL tree. </p>
<p>This function traverses the left subtree of the given root node to find and return the node containing the minimum value. If the tree is empty, it returns NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root node of the AVL tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the node with the smallest value, or NULL if the tree is empty. </dd></dl>

</div>
</div>
<a id="a3dda4ff3fb91cfd6c99bb7052b819e51" name="a3dda4ff3fb91cfd6c99bb7052b819e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dda4ff3fb91cfd6c99bb7052b819e51">&#9670;&#160;</a></span>height()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int height </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the height of an AVL tree. </p>
<p>This function computes the height of the subtree rooted at the given node. The height of a tree is the number of edges on the longest path from the node to a leaf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root node of the subtree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int The height of the subtree. Returns 0 if the subtree is empty. </dd></dl>

</div>
</div>
<a id="a078c52fc674fc34b00f340296349911e" name="a078c52fc674fc34b00f340296349911e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078c52fc674fc34b00f340296349911e">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> * insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new node with the given key into the AVL tree. </p>
<p>This function inserts a node with the specified key into the AVL tree rooted at 'root', maintaining the AVL tree balance property. If the key already exists, the tree remains unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root node of the AVL tree. </td></tr>
    <tr><td class="paramname">key</td><td>The integer key to insert into the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tnode* Pointer to the root node of the balanced AVL tree after insertion. </dd></dl>
<ol type="1">
<li>Perform the normal BST rotation</li>
</ol>
<ol type="1">
<li>Update height of this ancestor node</li>
</ol>
<ol type="1">
<li>Get the balance factor of this ancestor node to check whether this node became unbalanced</li>
</ol>

</div>
</div>
<a id="aa1ec4daa44e5cfbe76a48d11b7ecc434" name="aa1ec4daa44e5cfbe76a48d11b7ecc434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ec4daa44e5cfbe76a48d11b7ecc434">&#9670;&#160;</a></span>is_avl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_avl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a binary tree rooted at the given node is an AVL tree. </p>
<p>This function determines whether the binary tree with the specified root node satisfies the AVL (Adelson-Velsky and Landis) tree properties, i.e., it is a balanced binary search tree where the heights of the two child subtrees of any node differ by at most one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root node of the binary tree (tnode*). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Returns 1 if the tree is an AVL tree, 0 otherwise. </dd></dl>

</div>
</div>
<a id="ae66f6b31b5ad750f1fe042a706a4e3d4" name="ae66f6b31b5ad750f1fe042a706a4e3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66f6b31b5ad750f1fe042a706a4e3d4">&#9670;&#160;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point of the program. </p>
<p>This function serves as the main entry point for the AVL tree example program. It initializes necessary data structures and demonstrates AVL tree operations.</p>
<dl class="section return"><dt>Returns</dt><dd>int Returns 0 upon successful execution, or a non-zero value if an error occurs. </dd></dl>

</div>
</div>
<a id="af082905f7eac6d03e92015146bbc1925" name="af082905f7eac6d03e92015146bbc1925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af082905f7eac6d03e92015146bbc1925">&#9670;&#160;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int max </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum of two integer values. </p>
<p>Compares the two integer parameters and returns the greater of the two.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First integer value to compare. </td></tr>
    <tr><td class="paramname">b</td><td>Second integer value to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int The greater of the two integer values. </dd></dl>

</div>
</div>
<a id="a10c2ad0043c53c1ce457fb120626c907" name="a10c2ad0043c53c1ce457fb120626c907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c2ad0043c53c1ce457fb120626c907">&#9670;&#160;</a></span>new_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> * new_node </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new AVL tree node with the specified key. </p>
<p>Allocates memory for a new tree node, initializes its key with the given value, and sets its left and right child pointers to NULL. The height of the new node is typically initialized to 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The integer value to be stored in the new node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tnode* Pointer to the newly created node, or NULL if memory allocation fails. </dd></dl>

</div>
</div>
<a id="a36b292f4117a281cf5a25b509b56d235" name="a36b292f4117a281cf5a25b509b56d235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b292f4117a281cf5a25b509b56d235">&#9670;&#160;</a></span>print_inorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_inorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the nodes of an AVL tree in inorder traversal. </p>
<p>This function recursively traverses the AVL tree rooted at the given node and prints the value of each node in ascending order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root node of the AVL tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad85f111f1681b6b9f73530c712e14c45" name="ad85f111f1681b6b9f73530c712e14c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85f111f1681b6b9f73530c712e14c45">&#9670;&#160;</a></span>print_preorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_preorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the nodes of an AVL tree in preorder traversal. </p>
<p>This function recursively visits the root node first, then the left subtree, followed by the right subtree, printing the value of each node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root node of the AVL tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae3b6273d0ef04b893ab10b21c64b1b2" name="aae3b6273d0ef04b893ab10b21c64b1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3b6273d0ef04b893ab10b21c64b1b2">&#9670;&#160;</a></span>print_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>prelen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the structure of an AVL tree in a visually hierarchical format. </p>
<p>This function recursively traverses the AVL tree and prints each node with indentation corresponding to its depth in the tree, providing a visual representation of the tree structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root node of the AVL tree (or subtree) to print. </td></tr>
    <tr><td class="paramname">prelen</td><td>The current indentation level (number of spaces or characters to prefix each line), typically starts at 0 for the root and increases with tree depth. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae740ee9786bbaab4a07f134d560ceccf" name="ae740ee9786bbaab4a07f134d560ceccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae740ee9786bbaab4a07f134d560ceccf">&#9670;&#160;</a></span>rotate_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> * rotate_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a left rotation on the given AVL tree node. </p>
<p>This function rotates the subtree rooted at node x to the left, making x's right child the new root of the subtree. It is used to rebalance the AVL tree when the right subtree is heavier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to the root node of the subtree to rotate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tnode* Pointer to the new root of the rotated subtree. </dd></dl>

</div>
</div>
<a id="ab605122839c6c2e752001a093caea0d4" name="ab605122839c6c2e752001a093caea0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab605122839c6c2e752001a093caea0d4">&#9670;&#160;</a></span>rotate_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> * rotate_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *</td>          <td class="paramname"><span class="paramname"><em>y</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a right rotation on the given AVL tree node. </p>
<p>This function rotates the subtree rooted at node 'y' to the right, making its left child the new root of the subtree. It is used to rebalance the AVL tree when the left subtree becomes higher than the right subtree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Pointer to the root node of the subtree to rotate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tnode* Pointer to the new root node after rotation. </dd></dl>

</div>
</div>
<a id="a1f2a238d51d880f0c2f1f84270ad4f02" name="a1f2a238d51d880f0c2f1f84270ad4f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2a238d51d880f0c2f1f84270ad4f02">&#9670;&#160;</a></span>search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> * search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="avl__bitree__iterative_8c.html#ab7767888cfea8af07851e50456e4e0d8">tnode</a> *</td>          <td class="paramname"><span class="paramname"><em>tnp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for a node with the specified value in the AVL tree. </p>
<p>This function traverses the AVL tree rooted at 'tnp' to find a node containing the value 'val'. If such a node exists, a pointer to it is returned; otherwise, NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tnp</td><td>Pointer to the root node of the AVL tree. </td></tr>
    <tr><td class="paramname">val</td><td>The integer value to search for in the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tnode* Pointer to the node containing 'val', or NULL if not found. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="avl__tree_8c.html">avl_tree.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
